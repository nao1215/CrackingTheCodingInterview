
/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import java.util.Objects;
import java.util.HashMap;

public class App {
    public static void main(String[] args) {
        System.out.println(isPalindrome("abc cba"));
    }

    /*
     * [自作の解答] 文字の登場回数をHashMapに記録する。 文字数が偶数の場合は各文字の登場回数は偶数回となる。
     * 文字数が奇数の場合は各文字の登場回数は一文字だけ奇数で、 残りの文字の登場回数は偶数になる。
     *
     * 計算量はO(c)。 cは文字数。
     *
     * [制約] 漢字に対応できていない。記号やスペースを切り詰めるケースも対応できない。
     *
     * [未対応の例] "А роза упала на лапу Азора"や"A man, a plan, a canal: Panama"
     */
    public static boolean isPalindrome(String str) {
        HashMap<String, Integer> hashMap = new HashMap<String, Integer>(str.length());

        /* 文字の登場回数を記録する。 */
        for (int i = 0; i < str.length(); i++) {
            Integer value = 0;
            String tmp = str.substring(i, i + 1);
            if (hashMap.containsKey(tmp)) {
                value = hashMap.get(tmp) + 1;
            } else {
                value = 1;
            }
            hashMap.put(tmp, value);
        }

        int count = 0;
        for (Integer val : hashMap.values()) {
            /* 文字列の長さが偶数の場合 */
            if (isEvenNum(str.length()) && isOddNum(val.intValue())) {
                return false;
            }
            /* 文字列の長さが奇数の場合 */
            if (isOddNum(str.length()) && isOddNum(val.intValue())) {
                count++;
                if (count > 1) {
                    return false;
                }
            }
        }
        return true;
    }

    public static boolean isEvenNum(int num) {
        if (num % 2 == 0) {
            return true;
        }
        return false;
    }

    public static boolean isOddNum(int num) {
        if (num % 2 != 0) {
            return true;
        }
        return false;
    }

    /*
     * [書籍の解答1] 考え方は、自作の解答と同じだが、ASCII前提でコードを書いている。 計算量はO(c)。cは文字数。
     */
    public static boolean checkMaxOneOdd(int[] table) {
        boolean foundOdd = false;
        for (int count : table) {
            if (count % 2 == 1) {
                if (foundOdd) {
                    return false;
                }
                foundOdd = true;
            }
        }
        return true;
    }

    public static boolean isPermutationOfPalindrome(String phrase) {
        int[] table = Common.buildCharFrequencyTable(phrase);
        return checkMaxOneOdd(table);
    }

    /*
     * [書籍の解答2] １つ目の解答を最適化したもの。計算中に奇数の数を数える。計算量はO(c)。 cは文字数。
     */
    public static boolean isPermutationOfPalindromeBetter(String phrase) {
        int countOdd = 0;
        int[] table = new int[Character.getNumericValue('z') - Character.getNumericValue('a') + 1];
        for (char c : phrase.toCharArray()) {
            int x = Common.getCharNumber(c);
            if (x != -1) {
                table[x]++;

                if (table[x] % 2 == 1) {
                    countOdd++;
                } else {
                    countOdd--;
                }
            }
        }
        return countOdd <= 1;
    }

    /*
     * [書籍の解答3] ASCII（7Bit）を前提としたコード。計算量はO(c)。 cは文字数。
     * 同じ文字が偶数回登場した場合は、ライトのON/OFFのように、Bitが0になる。
     */
    /* 整数のi bit目を切り替える */
    public static int toggle(int bitVector, int index) {
        if (index < 0)
            return bitVector;

        int mask = 1 << index;
        if ((bitVector & mask) == 0) {
            bitVector |= mask;
        } else {
            bitVector &= ~mask;
        }
        return bitVector;
    }

    /* 文字列に対するBitベクトルを生成する。 各文字の文字番号iについて、iBit目を切り替える。 */
    public static int createBitVector(String phrase) {
        int bitVector = 0;
        for (char c : phrase.toCharArray()) {
            int x = Common.getCharNumber(c);
            bitVector = toggle(bitVector, x);
        }
        return bitVector;
    }

    /*
     * 整数値から1減算したものと元の数とのANDを取り、1Bitだけが1になっているかどうかをチェックする。
     */
    public static boolean checkAtMostOneBitSet(int bitVector) {
        return (bitVector & (bitVector - 1)) == 0;
    }

    public static boolean isPermutationOfPalindromeBit(String phrase) {
        int bitVector = createBitVector(phrase);
        return checkAtMostOneBitSet(bitVector);
    }
}
