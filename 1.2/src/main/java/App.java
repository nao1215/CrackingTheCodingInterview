/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import java.util.Arrays;
import java.util.Objects;

// 2つの文字列が与えられた時、片方がもう片方の並べ替えになっているかを決定するメソッド
public class App {
    public static void main(String[] args) {
        System.out.printf("%sと%sはアナグラム：%s\n",
        "test", "ttes", isAnagram("test", "ttes"));
        System.out.printf("%sと%sはアナグラム：%s\n",
        "tet", "tet", isAnagram("tet", "tet"));
        System.out.printf("%sと%sはアナグラム：%s\n",
        "あいう", "いうあ", isAnagram("あいう", "いうあ"));
        System.out.printf("%sと%sはアナグラム：%s\n",
        "123456789", "987654321", isAnagram("123456789", "987654321"));
        System.out.printf("%sと%sはアナグラム：%s\n",
        "[]:", "@[]", permutation("[]:", "@[]"));
    }

    /* [自作の解答]
     * 引数で与えた文字列str1、str2を比較し、
     * str1がstr2のアナグラムである場合はtrue、アナグラムではない場合はfalseを返す。
     * 方法論としては、書籍の解答1と同じ。
     *
     * 計算量はO(nlog(n))。
     * 総計算量は、文字列のソート部（sortStringInAsc()）の計算量に依存するが、
     * 今回はJava標準のソートメソッドを用いているため、O(nlog(n))。
     *  （本質的な問題の解き方ではない気がする）
     */
    public static boolean isAnagram(String str1, String str2) {
        if(Objects.isNull(str1) || Objects.isNull(str2)) {
            return false;
        }

        // 文字数が一致しない場合は、アナグラムではないとみなす
        if(str1.length() != str2.length()) {
            return false;
        }

        String sortedStr1 = sortStringInAsc(str1);
        String sortedStr2 = sortStringInAsc(str2);

        if(sortedStr1.equals(sortedStr2)) {
            return true;
        }
        return false;
    }

    /* 文字列を昇順ソートする。
     * Javaのドキュメントより、計算量がO(nlog(n))とされている。
     *
     * [引用]
     * ソート・アルゴリズムは、Vladimir Yaroslavskiy氏、Jon Bentley氏、
     * およびJoshua Bloch氏によるDual-Pivot Quicksortです。このアルゴリ
     * ズムは、ほかのクイックソート・アルゴリズムではnの2乗のパフォーマ
     * ンスに低下させる多くのデータ・セットで、O(n log(n))のパフォーマ
     * ンスを提供し、一般的に従来の(1ピボットの) Quicksortの実装よりも高速です。
     * 出典URL：https://docs.oracle.com/javase/jp/8/docs/api/java/util/Arrays.html#sort-char:A-
    */
    public static String sortStringInAsc(String str) {
        if(Objects.isNull(str)) {
            return null;
        }

        if((str.equals("")) || (str.length() ==1)) {
            return str;
        }

        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        String sortedStr = new String(chars);
        return sortedStr;
    }

    /* [書籍の解答2]
     * 文字コードをASCIIと仮定したコード。
     * アナグラムの場合は２つの文字列は同じ文字から構成されているので、
     * 同じ文字の数を数える事でアナグラムかどうかを判定する。
     */
    public static boolean permutation(String s, String t) {
        // 書籍には存在しないコード。NULLチェック
        if(Objects.isNull(s) || Objects.isNull(t)) {
            return false;
        }

        if(s.length() != t.length()) {
            return false;
        }

        // 書籍には存在しないコード。ASCII以外の文字列はfalseとして扱う。
        if (s.matches("^.*[^\\p{ASCII}].*") || t.matches("^.*[^\\p{ASCII}].*")) {
            return false;
        }

        /* ASCIIの場合、charAt()が返す値は0〜127に限定される。
         * 文字列1（s）で登場した文字はカウント（インクリメント）され、
         * letters配列に保持される（文字毎に登場数が保持される）。
         * 文字列2（t）で登場した文字は、letters配列の値をデクリメントする事で
         * カウントする。
         *
         * 文字列1と文字列2がアナグラムの場合、letters配列の値は全て0になる。
         * それ以外の場合、letters配列の値が負になった段階（文字列2にしか登場しない文字が
         * 出た段階）で、処理を中断する。
         */
        int[] letters = new int[128]; // ASCIIと仮定。ASCIIについては問題1.1参照。
        for(int i = 0; i<s.length(); i++) {
            letters[s.charAt(i)]++;
        }

        for(int i = 0; i<t.length(); i++) {
            letters[t.charAt(i)]--;
            if(letters[t.charAt(i)] < 0) {
                return false;
            }
        }
        return true; // 負（正）の値になる文字がない。
    }
}
